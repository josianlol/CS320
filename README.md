# CS320
Software Test, Automation QA

How can I ensure that my code, program, or software is functional and secure?

Ensuring that my code is functional and secure has been a recurring focus throughout this course, and I’ve learned some valuable strategies. Functional code starts with meeting all outlined requirements, as I’ve demonstrated in projects where I created services to manage contacts, tasks, and appointments. For example, I ensured each service adhered to strict requirements, such as enforcing unique IDs, setting length restrictions, and validating data to prevent errors. To verify functionality, I used JUnit tests extensively. Writing tests for every critical function allowed me to confirm that my code performed as expected under various scenarios.

When it comes to security, validating input and ensuring data integrity are key lessons I’ve applied. For instance, in the appointment service, I implemented logic to reject invalid dates or overly long descriptions. These practices ensure that no invalid data is processed, reducing risks of system vulnerabilities. Moving forward, I plan to adopt additional practices like encryption for sensitive data and access control mechanisms as I work on more complex projects.


How do I interpret user needs and incorporate them into a program?

Interpreting user needs starts with understanding the requirements and breaking them into actionable features. For example, when working on the contact, task, and appointment services, I focused on specific needs such as ensuring unique IDs, validating inputs, and providing flexibility for updates. These features were designed to solve practical challenges users might face, like avoiding duplicate entries or scheduling conflicts.

Incorporating user needs also means anticipating potential issues. For instance, I added input validation to prevent invalid data, like scheduling appointments in the past. Writing JUnit tests for every feature ensured the program worked as intended, even in edge cases. This approach not only met user expectations but also helped ensure the program's reliability.

Ultimately, addressing user needs requires thinking from their perspective. By prioritizing usability and planning carefully, I ensured the program handled common tasks efficiently while accounting for potential frustrations. 


How do I approach designing software?

Designing software, I’ve learned, is all about planning, structure, and iteration. Throughout this course, I used a modular approach, starting with small, functional classes like Contact, Task, and Appointment, then building services around them to manage data effectively. This design approach made it easier to test, debug, and extend functionality when needed.

Another important part of my approach is prioritizing simplicity and clarity. For example, I avoided overcomplicating the logic in any of my classes, focusing instead on meeting the requirements in a clean and efficient way. Using UML diagrams and breaking problems into manageable components were techniques I found very helpful, especially when tackling new assignments. Moving forward, I’ll continue using these design principles, while also learning more advanced methods like design patterns and agile methodologies to improve my processes.

In summary, this course has not only helped me improve my coding skills but has also given me a strong foundation in analyzing requirements, maintaining security, and designing robust software. These lessons will guide me in future projects and as I continue my journey in software development.
